import{_ as l,o as p,c as t,S as i}from"./chunks/framework.59c3ae61.js";const c=JSON.parse('{"title":"TCP、UDP 的概念及特点","description":"","frontmatter":{"isTimeLine":true,"title":"TCP、UDP 的概念及特点","date":"2023-9-13","tags":["面试经验","计算机网络"],"categories":["面试经验"]},"headers":[],"relativePath":"interview/计算机网络/TCP、UDP的概念及特点.md","filePath":"interview/计算机网络/TCP、UDP的概念及特点.md","lastUpdated":1694789489000}'),P={name:"interview/计算机网络/TCP、UDP的概念及特点.md"},a=i('<h1 id="tcp、udp-的概念及特点" tabindex="-1">TCP、UDP 的概念及特点 <a class="header-anchor" href="#tcp、udp-的概念及特点" aria-label="Permalink to &quot;TCP、UDP 的概念及特点&quot;">​</a></h1><p>TCP、UDP 都是传输层协议，他们同属于 TCP/IP 协议族。在网络中它们用于处理数据包。</p><p>在 OSI 模型中，他们属于传输层（IP 协议的上一层）</p><h2 id="udp-用户数据报协议" tabindex="-1">UDP（用户数据报协议） <a class="header-anchor" href="#udp-用户数据报协议" aria-label="Permalink to &quot;UDP（用户数据报协议）&quot;">​</a></h2><p>UDP 是一种无连接的协议。</p><p>UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p><strong>UDP 的特点包括</strong>：</p><ol><li>面向无连接</li></ol><p>UDP 不需要像 TCP 那样在发送数据前三次握手建立连接，随时可以发送数据。它只负责传输数据报文，并不会对数据报文进行任何拆分和拼接操作。</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头，用来标识 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><ol start="2"><li>支持单播、多播、广播</li></ol><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><ol start="3"><li>面向报文</li></ol><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p><ol start="4"><li>不可靠性</li></ol><ul><li><p>UDP 的不可靠性首先体现在无连接上，它的通信不需要建立连接，随用随发。</p></li><li><p>它只会对收到的数据进行传递，不会对它进行备份，也不会关注接收方是否成功接收到了数据。</p></li><li><p>由于 UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。所以可能导致网络不好的情况下会出现丢包。</p></li><li><p>也正是由于这种性质，使得 UDP 的实时效率远远高于 TCP，在一些实时性要求较高的场景下（直播、视频电话、在线游戏）就会去使用 UDP 进行通信。</p></li></ul><ol start="5"><li>头部开销小，能高效地传输数据报文</li></ol><p>UDP 头部只包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p><p><strong>UDP 不可靠的原因</strong>：</p><p>UDP 在传输数据之前不需要先建立连接，接收端的传输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><h2 id="tcp-传输控制协议" tabindex="-1">TCP（传输控制协议） <a class="header-anchor" href="#tcp-传输控制协议" aria-label="Permalink to &quot;TCP（传输控制协议）&quot;">​</a></h2><p>TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p><strong>TCP 的特点包括</strong>：</p><ol><li>面向连接</li></ol><p>TCP 在发送数据之前必须在两端建立连接。通过“三次握手”能够建立可靠的链接，为数据的可靠传输打下基础。</p><ol start="2"><li>单播传输</li></ol><p>TCP 仅支持单薄传输，每一次传输连接只能有两个端点，不支持多播和广播。</p><ol start="3"><li>面向字节流</li></ol><p>不同于 UDP 那样面向报文的传输，TCP 可以在不保留边界的条件下以字节流的方式进行传输。</p><ol start="4"><li>可靠传输</li></ol><p>TCP 判断丢包、误码靠的是 TCP 的段编号以及确认号。</p><p>TCP 为了保证报文传输的可靠性，会给每个包一个序号，这个序号也保证了接收端能够按序接收包。</p><p>接收端实体会对每一个成功收到的包发送一个相应的确认。</p><p>如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（会被认定为丢失了）将会被重传。</p><ol start="5"><li>拥塞控制</li></ol><p>网络出现拥塞时，TCP 能减小向网络注入数据的速率和数量，缓解拥塞。</p><ol start="6"><li>支持全双工通信</li></ol><p>TCP 允许通信双方在任何时刻发送数据，因为TCP连接的两端都设有缓存，用来临时存放<em>双向通信</em>的数据。</p><p>TCP 可以立即发送一个数据端，也可以缓存一段时间后，一次发送更多数据段。</p><p><strong>TCP 的重传机制</strong>：</p><p>由于 TCP 的下层网络（网络层），可能出现<em>丢失、重复或失序的情况</em>，TCP 协议提供可靠数据传输服务，为了保证数据传输的正确性，TCP 会重传已被认为丢失的包。</p><p>TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。</p><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的 ACK 确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h2 id="tcp-和-udp-的应用场景" tabindex="-1">TCP 和 UDP 的应用场景 <a class="header-anchor" href="#tcp-和-udp-的应用场景" aria-label="Permalink to &quot;TCP 和 UDP 的应用场景&quot;">​</a></h2><p><strong>TCP</strong>: 适用于效率要求较低，准确性要求相对高的场景。由于传输中需要对数据进行确认、重发、排序等操作，效率低于 UDP。</p><p>例如： 文件传输、邮件传输、远程登陆、Web 应用程序</p><p><strong>UDP</strong>：适用于效率要求高，准确性要求低的场景。</p><p>例如：QQ聊天、在线直播、广播通信</p>',51),e=[a];function o(r,s,n,T,D,C){return p(),t("div",null,e)}const d=l(P,[["render",o]]);export{c as __pageData,d as default};
